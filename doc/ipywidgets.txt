https://github.com/jupyter-widgets/tutorial/blob/main/notebooks/05.Build-complex-libs/05.00-Build-complex-libraries.ipynb
https://github.com/bqplot/bqplot

In addition to interact, IPython provides another function, interactive, that is useful when you want to reuse the widgets that are produced or access the data that is bound to the UI controls.

from IPython.display import display

def f(a, b):
    display(a + b)
    return a+b
    
interactive returns a Widget instance rather than immediately displaying the widget.
w = interactive(f, a=10, b=20)
The widget is an interactive, a subclass of VBox, which is a container for other widgets.
To actually display the widgets, you can use IPython's display function.
display(w)
the widget instance returned by interactive also gives you access to the current keyword arguments and return value of the underlying Python function
w.kwargs
w.result

foo = interactive(slow_function, {'manual': True}, i=widgets.FloatSlider(min=1e4, max=1e6, step=1e4))


interactive_output provides additional flexibility: you can control how the UI elements are laid out.
Unlike interact, interactive, and interact_manual, interactive_output does not generate a user interface for the widgets. This is powerful, because it means you can create a widget, put it in a box, and then pass the widget to interactive_output, and have control over the widget and its layout.

import ipywidgets as widgets

a = widgets.IntSlider()
b = widgets.IntSlider()
c = widgets.IntSlider()

# An HBox lays out its children horizontally
ui = widgets.HBox([a, b, c])

def f(a, b, c):
    # You can use print here instead of display because interactive_output generates a normal notebook 
    # output area.
    print((a, b, c))

out = widgets.interactive_output(f, {'a': a, 'b': b, 'c': c})

You can also explicitly display the widget using display(...)
w = widgets.IntSlider()
display(w)

To read the value of a widget, you can query its value property

w.value
w.value = 100


In addition to value, most widgets share keys, description, and disabled

Almost every widget can be observed for changes in its value that trigger a call to a function. The example below is the slider from the first notebook of the tutorial.
slider = widgets.FloatSlider(
    value=7.5,
    min=5.0,
    max=10.0,
    step=0.1,
    description='Input:',
)

# Create non-editable text area to display square of value
square_display = widgets.HTML(description="Square: ", value='{}'.format(slider.value**2))

# Create function to update square_display's value when slider changes
def update_square_display(change):
    square_display.value = '{}'.format(change.new**2)
    
slider.observe(update_square_display, names='value')

# Put them in a vertical box
widgets.VBox([slider, square_display])

The Output widget can capture and display stdout, stderr and rich output generated by IPython. You can also append output directly to an output widget, or clear it programmatically.



 
 

display(ui, out)

